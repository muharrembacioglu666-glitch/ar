<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <title>Oyun Portalı v1.8.3</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap');

        :root {
            --primary-yellow: #ffcc00;
            --bg-dark: #121212;
            --card-bg: #1e1e1e;
        }

        body {
            margin: 0;
            background-color: var(--bg-dark);
            color: #fff;
            font-family: 'Poppins', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        /* HEADER */
        header {
            width: 100%;
            padding: 20px 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            background: #1a1a1a;
            border-bottom: 2px solid #333;
            position: relative;
            z-index: 10;
        }

        .logo {
            font-size: 24px;
            font-weight: 800;
            color: var(--primary-yellow);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-links {
            display: flex;
            gap: 20px;
            font-size: 14px;
            color: #aaa;
        }

        .nav-links span.active {
            color: var(--primary-yellow);
            font-weight: 600;
        }

        /* DÖNEN RENKLİ SÜRÜM ROZETİ */
        .version-wrapper {
            position: relative;
            padding: 2px;
            border-radius: 20px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .version-wrapper:hover { transform: scale(1.05); }

        .version-wrapper::before {
            content: '';
            position: absolute;
            top: -50%; left: -50%;
            width: 200%; height: 200%;
            background: conic-gradient(#ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #8f00ff, #ff0000);
            animation: rotateBorder 2s linear infinite;
            z-index: 0;
        }

        @keyframes rotateBorder { 100% { transform: rotate(360deg); } }

        .version-badge {
            position: relative;
            background: #000;
            padding: 5px 15px;
            border-radius: 18px;
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            z-index: 1;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* MENÜ */
        #menu-screen {
            text-align: center;
            margin-top: 50px;
            animation: fadeIn 0.5s;
        }

        h2.section-title { font-size: 28px; margin-bottom: 30px; }

        .games-grid {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .game-card {
            background: var(--card-bg);
            border: 1px solid #333;
            border-radius: 15px;
            width: 280px;
            padding: 40px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        .game-card:hover {
            transform: translateY(-5px);
            border-color: var(--primary-yellow);
            box-shadow: 0 0 15px rgba(255, 204, 0, 0.2);
        }

        .game-icon svg {
            width: 60px; height: 60px;
            fill: none; stroke: var(--primary-yellow); stroke-width: 3;
            stroke-linecap: round; stroke-linejoin: round;
        }
        .game-icon.fill svg { fill: var(--primary-yellow); stroke: none; }

        .game-title { font-weight: 700; font-size: 20px; }
        .game-desc { font-size: 13px; color: #888; }

        /* OYUN ALANI */
        #game-container {
            display: none;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            width: 100%;
        }

        .game-header {
            display: flex; justify-content: space-between;
            width: 600px; margin-bottom: 10px; align-items: center;
        }

        .back-btn {
            background: #333; border: none; color: white;
            padding: 8px 16px; border-radius: 5px; cursor: pointer;
        }
        .back-btn:hover { background: #444; }

        canvas {
            background: #000; border: 2px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.5); display: block;
        }

        /* MODAL */
        .modal-overlay {
            display: none; position: fixed; top: 0; left: 0;
            width: 100%; height: 100%; background: rgba(0,0,0,0.8);
            z-index: 100; justify-content: center; align-items: center;
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background: #1a1a1a; width: 500px; max-height: 80vh;
            border-radius: 15px; border: 1px solid #444; padding: 30px;
            overflow-y: auto; position: relative;
        }
        .changelog-item { margin-bottom: 20px; }
        .version-title { color: var(--primary-yellow); font-weight: bold; margin-bottom: 5px; }
        .change-list { list-style: none; padding: 0; margin: 0; font-size: 13px; color: #ccc; }
        .change-list li::before { content: '•'; color: #555; position: absolute; left: 0; }
        .change-list li { margin-bottom: 5px; padding-left: 15px; position: relative; }
        .close-modal { background: none; border: none; color: #888; font-size: 24px; cursor: pointer; float: right; }

        /* GAME OVER */
        #game-over-screen {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95); padding: 40px;
            border-radius: 15px; text-align: center; display: none;
            border: 2px solid var(--primary-yellow); z-index: 50;
        }
        .restart-btn {
            background: #2196F3; color: white; border: none;
            padding: 10px 20px; font-size: 16px; border-radius: 5px;
            cursor: pointer; margin-top: 15px;
        }
    </style>
</head>
<body>

    <header>
        <div class="logo">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#ffcc00" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="6" width="20" height="12" rx="2"></rect><path d="M6 12h4m-2-2v4"></path><line x1="15" y1="11" x2="15" y2="11"></line><line x1="18" y1="13" x2="18" y2="13"></line></svg>
            OYUN PORTALI
        </div>
        <div class="nav-links">
            <span>Anasayfa</span>
            <span class="active">Oyunlar</span>
            <span>Ders Notları</span>
            <span>Filmler</span>
        </div>
        <div class="version-wrapper" onclick="openChangelog()">
            <div class="version-badge">v1.8.3 <span>ℹ</span></div>
        </div>
    </header>

    <div id="changelog-modal" class="modal-overlay">
        <div class="modal-content">
            <button class="close-modal" onclick="closeChangelog()">×</button>
            <h3 style="margin-top:0">Sürüm Geçmişi</h3>
            
            <div class="changelog-item">
                <div class="version-title">v1.8.3 (Güncel)</div>
                <ul class="change-list">
                    <li>Yılan Oyunu: Yılana yön gösteren kafa ve gözler eklendi!</li>
                    <li>Sürüm numarası v1.8.3'e yükseltildi.</li>
                </ul>
            </div>
            <div class="changelog-item">
                <div class="version-title">v1.8.2</div>
                <ul class="change-list">
                    <li>Tetris bloklarının gelmeme sorunu düzeltildi.</li>
                    <li>Pac-Man'de hayalet sayısı 1'e indirildi.</li>
                    <li>Hayalet Yapay Zekası: Artık seni takip ediyor!</li>
                </ul>
            </div>
        </div>
    </div>

    <div id="menu-screen">
        <h2 class="section-title">Oyun Kütüphanesi</h2>
        <div class="games-grid">
            <div class="game-card" onclick="startGame('snake')">
                <div class="game-icon">
                    <svg viewBox="0 0 24 24"><path d="M7 4v2a2 2 0 0 1-2 2H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2a2 2 0 0 1 2 2v2" stroke="#ffcc00"></path><circle cx="8" cy="4" r="2" fill="#ffcc00" stroke="none"></circle></svg>
                </div>
                <div class="game-title">Yılan Oyunu</div>
                <div class="game-desc">Yeni: Gözlü kafa eklendi!</div>
            </div>

            <div class="game-card" onclick="startGame('tetris')">
                <div class="game-icon fill">
                    <svg viewBox="0 0 24 24"><rect x="2" y="2" width="9" height="9" rx="1"></rect><rect x="13" y="2" width="9" height="9" rx="1"></rect><rect x="2" y="13" width="9" height="9" rx="1"></rect><rect x="13" y="13" width="9" height="9" rx="1"></rect></svg>
                </div>
                <div class="game-title">Tetris</div>
                <div class="game-desc">Blokları yerleştir, satırları yok et.</div>
            </div>

            <div class="game-card" onclick="startGame('pacman')">
                <div class="game-icon fill">
                    <svg viewBox="0 0 24 24"><path d="M12 2a8 8 0 0 0-8 8v10a2 2 0 0 0 2 2c.5 0 1-.5 1.5-1s1 1 1.5 1 1.5-1 1.5-1 1.5 1 1.5-1 1.5-1 2-2V10a8 8 0 0 0-8-8z"></path><circle cx="9" cy="9" r="1.5" fill="#000"></circle><circle cx="15" cy="9" r="1.5" fill="#000"></circle></svg>
                </div>
                <div class="game-title">Pac-Man</div>
                <div class="game-desc">1 Akıllı Hayalet, 3 Can Hakkı.</div>
            </div>
        </div>
    </div>

    <div id="game-container">
        <div class="game-header">
            <button class="back-btn" onclick="backToMenu()">← Menü</button>
            <div id="score-display" style="font-weight:bold; color:#ffcc00; font-size:18px;">SKOR: 0</div>
        </div>
        <div style="position: relative;">
            <canvas id="gameCanvas" width="600" height="600"></canvas>
            <div id="game-over-screen">
                <div style="color: #ff4444; font-size: 32px; font-weight: bold; margin-bottom: 10px;">OYUN BİTTİ</div>
                <div id="final-score" style="font-size: 24px; color: #fff;">Skor: 0</div>
                <button class="restart-btn" onclick="restartGame()">Tekrar Oyna</button>
            </div>
        </div>
    </div>

    <script>
        // MODAL
        function openChangelog() { document.getElementById('changelog-modal').style.display = 'flex'; }
        function closeChangelog() { document.getElementById('changelog-modal').style.display = 'none'; }
        window.onclick = function(e) { if(e.target == document.getElementById('changelog-modal')) closeChangelog(); }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const menuScreen = document.getElementById('menu-screen');
        const gameContainer = document.getElementById('game-container');
        const scoreDisplay = document.getElementById('score-display');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreText = document.getElementById('final-score');

        let activeGame = null;
        let gameInterval = null;
        let score = 0;
        let isGameOver = false;

        function startGame(type) {
            menuScreen.style.display = 'none';
            gameContainer.style.display = 'flex';
            activeGame = type;
            isGameOver = false;
            gameOverScreen.style.display = 'none';
            score = 0;
            updateScore(0);
            if(gameInterval) clearInterval(gameInterval);
            
            document.onkeydown = null;
            document.onkeydown = handleInput;

            if(type === 'snake') initSnake();
            if(type === 'tetris') initTetris();
            if(type === 'pacman') initPacman();
        }

        function backToMenu() {
            if(gameInterval) clearInterval(gameInterval);
            gameContainer.style.display = 'none';
            menuScreen.style.display = 'block';
            activeGame = null;
        }

        function showGameOver(text) {
            clearInterval(gameInterval);
            isGameOver = true;
            finalScoreText.innerText = text || `Skor: ${score}`;
            gameOverScreen.style.display = 'block';
        }

        function restartGame() { startGame(activeGame); }

        function updateScore(val) {
            score = val;
            if(activeGame === 'pacman') scoreDisplay.innerText = `SKOR: ${score} | CAN: ${pacmanLives}`;
            else scoreDisplay.innerText = `SKOR: ${score}`;
        }

        function handleInput(e) {
            if(isGameOver) return;
            if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.code)) e.preventDefault();
            
            if(activeGame === 'snake') handleSnakeInput(e);
            if(activeGame === 'tetris') handleTetrisInput(e);
            if(activeGame === 'pacman') handlePacmanInput(e);
        }

        // ======================== YILAN (SNAKE) - KAFA EKLENDİ ========================
        let snake=[], apple={}, snakeDir={}, nextSnakeDir={};
        const sGrid=25, sCols=24, sRows=24;

        function initSnake() {
            canvas.width = 600; canvas.height = 600;
            snake = [{x:10,y:10}, {x:9,y:10}, {x:8,y:10}];
            snakeDir = {x:1, y:0}; nextSnakeDir = {x:1, y:0};
            apple = spawnApple();
            gameInterval = setInterval(updateSnake, 100);
        }

        function spawnApple() { return {x: Math.floor(Math.random()*sCols), y: Math.floor(Math.random()*sRows)}; }

        function handleSnakeInput(e) {
            if(e.key==='ArrowUp' && snakeDir.y===0) nextSnakeDir={x:0, y:-1};
            if(e.key==='ArrowDown' && snakeDir.y===0) nextSnakeDir={x:0, y:1};
            if(e.key==='ArrowLeft' && snakeDir.x===0) nextSnakeDir={x:-1, y:0};
            if(e.key==='ArrowRight' && snakeDir.x===0) nextSnakeDir={x:1, y:0};
        }

        function updateSnake() {
            snakeDir = nextSnakeDir;
            let head = {x: snake[0].x + snakeDir.x, y: snake[0].y + snakeDir.y};

            if(head.x<0 || head.x>=sCols || head.y<0 || head.y>=sRows) return showGameOver();
            if(snake.some(p => p.x===head.x && p.y===head.y)) return showGameOver();

            snake.unshift(head);
            if(head.x===apple.x && head.y===apple.y) {
                score++; updateScore(score); apple = spawnApple();
            } else snake.pop();

            // Çizim - Zemin
            for(let r=0; r<sRows; r++) {
                for(let c=0; c<sCols; c++) {
                    ctx.fillStyle = (r+c)%2===0 ? "#aad751" : "#a2d149";
                    ctx.fillRect(c*sGrid, r*sGrid, sGrid, sGrid);
                }
            }

            // Elma
            ctx.fillStyle="#e7471d";
            ctx.beginPath(); ctx.arc(apple.x*sGrid+sGrid/2, apple.y*sGrid+sGrid/2, sGrid/2-2, 0, Math.PI*2); ctx.fill();
            
            // Yılan Çizimi
            snake.forEach((p, i) => {
                // Gövde Rengi (Kafa daha parlak mavi)
                ctx.fillStyle = (i === 0) ? "#4674E9" : "#315ecb";
                ctx.fillRect(p.x*sGrid+1, p.y*sGrid+1, sGrid-2, sGrid-2);

                // KAFAYA GÖZ EKLEME
                if(i === 0) {
                    ctx.fillStyle = "white";
                    const eyeSize = 3;
                    let eyeX1, eyeY1, eyeX2, eyeY2;

                    // Göz konumlarını yılanın yönüne göre belirle
                    if(snakeDir.x === 1) { // Sağ
                        eyeX1 = eyeX2 = p.x*sGrid + 18;
                        eyeY1 = p.y*sGrid + 6; eyeY2 = p.y*sGrid + 18;
                    } else if(snakeDir.x === -1) { // Sol
                        eyeX1 = eyeX2 = p.x*sGrid + 6;
                        eyeY1 = p.y*sGrid + 6; eyeY2 = p.y*sGrid + 18;
                    } else if(snakeDir.y === -1) { // Yukarı
                        eyeY1 = eyeY2 = p.y*sGrid + 6;
                        eyeX1 = p.x*sGrid + 6; eyeX2 = p.x*sGrid + 18;
                    } else { // Aşağı
                        eyeY1 = eyeY2 = p.y*sGrid + 18;
                        eyeX1 = p.x*sGrid + 6; eyeX2 = p.x*sGrid + 18;
                    }

                    // Göz Akı
                    ctx.beginPath();
                    ctx.arc(eyeX1, eyeY1, eyeSize, 0, Math.PI*2);
                    ctx.arc(eyeX2, eyeY2, eyeSize, 0, Math.PI*2);
                    ctx.fill();

                    // Göz Bebeği
                    ctx.fillStyle = "black";
                    ctx.beginPath();
                    ctx.arc(eyeX1, eyeY1, 1.5, 0, Math.PI*2);
                    ctx.arc(eyeX2, eyeY2, 1.5, 0, Math.PI*2);
                    ctx.fill();
                }
            });
        }

        // ======================== TETRIS ========================
        const tRows=20, tCols=10, tSize=30;
        let board=[], currentPiece=null;
        const TETROMINOS = [
            { matrix: [[1,1,1,1]], color: "cyan" },
            { matrix: [[1,1],[1,1]], color: "yellow" },
            { matrix: [[0,1,0],[1,1,1]], color: "purple" },
            { matrix: [[0,1,1],[1,1,0]], color: "green" },
            { matrix: [[1,1,0],[0,1,1]], color: "red" },
            { matrix: [[1,0,0],[1,1,1]], color: "blue" },
            { matrix: [[0,0,1],[1,1,1]], color: "orange" }
        ];

        function initTetris() {
            canvas.width = 300; canvas.height = 600;
            board = Array.from({length: tRows}, () => Array(tCols).fill(null));
            score = 0;
            spawnTetrisPiece();
            gameInterval = setInterval(updateTetris, 1000);
            drawTetris();
        }

        function spawnTetrisPiece() {
            const r = Math.floor(Math.random() * TETROMINOS.length);
            const pieceData = TETROMINOS[r];
            const matrixCopy = JSON.parse(JSON.stringify(pieceData.matrix));
            currentPiece = { matrix: matrixCopy, color: pieceData.color, x: 3, y: 0 };
            if (checkCollision(0, 0, currentPiece.matrix)) showGameOver(`Tetris Bitti! Skor: ${score}`);
        }

        function updateTetris() { moveTetrisDown(); drawTetris(); }

        function moveTetrisDown() {
            if(!currentPiece) return;
            if(!checkCollision(0, 1, currentPiece.matrix)) { currentPiece.y++; } 
            else { lockTetrisPiece(); spawnTetrisPiece(); }
        }

        function handleTetrisInput(e) {
            if(!currentPiece || isGameOver) return;
            if(e.key === 'ArrowLeft') { if(!checkCollision(-1, 0, currentPiece.matrix)) currentPiece.x--; } 
            else if(e.key === 'ArrowRight') { if(!checkCollision(1, 0, currentPiece.matrix)) currentPiece.x++; } 
            else if(e.key === 'ArrowDown') { moveTetrisDown(); } 
            else if(e.key === 'ArrowUp') {
                const rotated = currentPiece.matrix[0].map((_, i) => currentPiece.matrix.map(row => row[i]).reverse());
                if(!checkCollision(0, 0, rotated)) currentPiece.matrix = rotated;
            }
            drawTetris();
        }

        function checkCollision(offX, offY, matrix) {
            for(let r=0; r<matrix.length; r++) for(let c=0; c<matrix[r].length; c++) if(matrix[r][c]){
                let newX = currentPiece.x + c + offX;
                let newY = currentPiece.y + r + offY;
                if(newX < 0 || newX >= tCols || newY >= tRows) return true; 
                if(newY >= 0 && board[newY][newX]) return true;
            }
            return false;
        }

        function lockTetrisPiece() {
            currentPiece.matrix.forEach((row, r) => row.forEach((val, c) => {
                if(val && currentPiece.y + r >= 0) board[currentPiece.y+r][currentPiece.x+c] = currentPiece.color;
            }));
            for(let r=0; r<tRows; r++) if(board[r].every(cell => cell !== null)) {
                board.splice(r, 1); board.unshift(Array(tCols).fill(null));
                score += 100; updateScore(score);
            }
        }

        function drawTetris() {
            ctx.fillStyle = "#111"; ctx.fillRect(0,0,canvas.width, canvas.height);
            for(let r=0; r<tRows; r++) for(let c=0; c<tCols; c++) if(board[r][c]) drawBlock(c, r, board[r][c]);
            if(currentPiece) currentPiece.matrix.forEach((row, r) => row.forEach((val, c) => {
                if(val) drawBlock(currentPiece.x+c, currentPiece.y+r, currentPiece.color);
            }));
        }

        function drawBlock(x, y, color) {
            ctx.fillStyle = color; ctx.fillRect(x*tSize, y*tSize, tSize, tSize);
            ctx.strokeStyle = "#000"; ctx.lineWidth = 2; ctx.strokeRect(x*tSize, y*tSize, tSize, tSize);
        }

        // ======================== PACMAN ========================
        const pGrid = 20, pCols = 19;
        const pMapLayout = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,1,1,1,0,1,1,1,2,1,2,1,1,1,0,1,1,1,1],
            [2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2],
            [1,1,1,1,0,1,2,1,1,2,1,1,2,1,0,1,1,1,1],
            [1,0,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0,0,1], 
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,0,0,1,0,0,0,0,0,3,0,0,0,0,0,1,0,0,1],
            [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        
        let pacman={}, ghost={}, pacmanLives=3, pacMap=[];

        function initPacman() {
            canvas.width = pCols * 30; canvas.height = pMapLayout.length * 30;
            pacMap = JSON.parse(JSON.stringify(pMapLayout));
            score=0; pacmanLives=3;
            resetPacPositions();
            updateScore(0);
            gameInterval = setInterval(updatePacman, 150);
        }

        function resetPacPositions() {
            pacman = {x: 9, y: 12, dirX:0, dirY:0, nextDirX:0, nextDirY:0};
            ghost = {x: 9, y: 8, color: 'red'};
        }

        function handlePacmanInput(e) {
            if(e.key==='ArrowUp') { pacman.nextDirX=0; pacman.nextDirY=-1; }
            if(e.key==='ArrowDown') { pacman.nextDirX=0; pacman.nextDirY=1; }
            if(e.key==='ArrowLeft') { pacman.nextDirX=-1; pacman.nextDirY=0; }
            if(e.key==='ArrowRight') { pacman.nextDirX=1; pacman.nextDirY=0; }
        }

        function updatePacman() {
            let nextX = pacman.x + pacman.nextDirX;
            let nextY = pacman.y + pacman.nextDirY;
            if(pacMap[nextY] && pacMap[nextY][nextX] !== 1) { pacman.dirX = pacman.nextDirX; pacman.dirY = pacman.nextDirY; }

            let moveX = pacman.x + pacman.dirX;
            let moveY = pacman.y + pacman.dirY;
            if(pacMap[moveY] && pacMap[moveY][moveX] !== 1) { pacman.x = moveX; pacman.y = moveY; }

            if(pacman.x < 0) pacman.x = pCols-1;
            if(pacman.x >= pCols) pacman.x = 0;

            if(pacMap[pacman.y][pacman.x] === 0) { pacMap[pacman.y][pacman.x] = 2; score+=10; updateScore(score); }

            // Hayalet AI
            let possibleMoves = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}];
            let validMoves = possibleMoves.filter(m => pacMap[ghost.y+m.y] && pacMap[ghost.y+m.y][ghost.x+m.x] !== 1);
            let bestMove = null; let minDistance = 9999;
            validMoves.forEach(m => {
                let dist = Math.abs(ghost.x+m.x - pacman.x) + Math.abs(ghost.y+m.y - pacman.y);
                if (dist < minDistance) { minDistance = dist; bestMove = m; }
            });
            if (bestMove) { ghost.x += bestMove.x; ghost.y += bestMove.y; }

            if(ghost.x === pacman.x && ghost.y === pacman.y) {
                pacmanLives--; updateScore(score);
                if(pacmanLives<=0) showGameOver(); else resetPacPositions();
            }
            drawPacman();
        }

        function drawPacman() {
            let s = 30; ctx.fillStyle="black"; ctx.fillRect(0,0,canvas.width,canvas.height);
            for(let r=0; r<pacMap.length; r++) for(let c=0; c<pacMap[r].length; c++){
                if(pacMap[r][c]===1) { ctx.strokeStyle="#1919A6"; ctx.lineWidth=2; ctx.strokeRect(c*s+5,r*s+5,s-10,s-10); } 
                else if(pacMap[r][c]===0) { ctx.fillStyle="#ffb8ae"; ctx.fillRect(c*s+13,r*s+13,4,4); }
            }
            ctx.fillStyle="yellow"; ctx.beginPath(); ctx.arc(pacman.x*s+s/2, pacman.y*s+s/2, s/2-2, 0.2*Math.PI, 1.8*Math.PI); ctx.lineTo(pacman.x*s+s/2, pacman.y*s+s/2); ctx.fill();
            ctx.fillStyle=ghost.color; ctx.beginPath(); ctx.arc(ghost.x*s+s/2, ghost.y*s+s/2, s/2-4, 0, Math.PI*2); ctx.fill();
        }
    </script>
</body>
</html>
