<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <title>Oyun Portalƒ± v1.8.0</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap');

        body {
            margin: 0;
            background-color: #121212;
            color: #fff;
            font-family: 'Poppins', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        /* HEADER */
        header {
            width: 100%;
            padding: 20px 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            background: #1a1a1a;
            border-bottom: 2px solid #333;
        }

        .logo {
            font-size: 24px;
            font-weight: 800;
            color: #ffcc00;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-links {
            display: flex;
            gap: 20px;
            font-size: 14px;
            color: #aaa;
        }

        .nav-links span.active {
            color: #ffcc00;
            font-weight: 600;
        }

        .version-badge {
            background: linear-gradient(45deg, #ff00cc, #3333ff);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }

        /* MENU EKRANI */
        #menu-screen {
            text-align: center;
            margin-top: 50px;
            animation: fadeIn 0.5s;
        }

        h2.section-title {
            margin-bottom: 30px;
            font-size: 28px;
        }

        .games-grid {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .game-card {
            background: #1e1e1e;
            border: 1px solid #333;
            border-radius: 10px;
            width: 250px;
            padding: 30px 20px;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .game-card:hover {
            transform: translateY(-5px);
            border-color: #ffcc00;
        }

        .icon {
            font-size: 50px;
        }

        .game-title {
            font-weight: 700;
            font-size: 18px;
        }

        .game-desc {
            font-size: 12px;
            color: #888;
            line-height: 1.4;
        }

        /* OYUN ALANI */
        #game-container {
            display: none;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            width: 100%;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            width: 600px;
            margin-bottom: 10px;
            align-items: center;
        }

        .back-btn {
            background: #333;
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
        }

        .back-btn:hover { background: #444; }

        canvas {
            background: #000;
            border: 2px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            display: block;
        }

        /* GAME OVER OVERLAY */
        #game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            display: none;
            border: 2px solid #ffcc00;
            z-index: 100;
        }
        
        #game-over-title { color: #ff4444; font-size: 32px; font-weight: bold; margin-bottom: 10px; }
        #final-score { font-size: 24px; color: #fff; margin-bottom: 20px; }
        
        .restart-btn {
            background: #2196F3;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
        }
        .restart-btn:hover { background: #1976D2; }

        /* HUD & SCOREBOARDS */
        .hud-info {
            font-size: 18px;
            font-weight: bold;
            color: #ffcc00;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Snake √ñzel Stillendirme (Google Snake Tarzƒ±) */
        .snake-score-board {
            position: absolute;
            top: 100px; /* Canvasƒ±n √ºst√ºne */
            left: 50%;
            transform: translateX(-50%);
            display: none; /* JS ile a√ßƒ±lacak */
            background: rgba(0,0,0,0.5);
            padding: 5px 15px;
            border-radius: 10px;
            font-size: 20px;
            z-index: 10;
        }
    </style>
</head>
<body>

    <header>
        <div class="logo">
            <span>+ ‚Ä¢</span> OYUN PORTALI
        </div>
        <div class="nav-links">
            <span>Anasayfa</span>
            <span class="active">Oyunlar</span>
            <span>Ders Notlarƒ±</span>
            <span>Filmler</span>
        </div>
        <div class="version-badge">v1.8.0 ‚Ñπ</div>
    </header>

    <div id="menu-screen">
        <h2 class="section-title">Oyun K√ºt√ºphanesi</h2>
        <div class="games-grid">
            <div class="game-card" onclick="startGame('snake')">
                <div class="icon">üêç</div>
                <div class="game-title">Yƒ±lan Oyunu</div>
                <div class="game-desc">Duvarlara √ßarpma, elmalarƒ± topla! (Google Style)</div>
            </div>
            <div class="game-card" onclick="startGame('tetris')">
                <div class="icon">Áî∞</div>
                <div class="game-title">Tetris</div>
                <div class="game-desc">Tam fonksiyonlu: √áevir (‚Üë), Hƒ±zlandƒ±r (‚Üì).</div>
            </div>
            <div class="game-card" onclick="startGame('pacman')">
                <div class="icon">üëª</div>
                <div class="game-title">Pac-Man</div>
                <div class="game-desc">3 Can Hakkƒ±, Klasik Labirent.</div>
            </div>
        </div>
    </div>

    <div id="game-container">
        <div class="game-header">
            <button class="back-btn" onclick="backToMenu()">‚Üê Men√º</button>
            <div id="score-display" class="hud-info">SKOR: 0</div>
        </div>
        
        <div style="position: relative;">
            <canvas id="gameCanvas" width="600" height="600"></canvas>
            
            <div id="game-over-screen">
                <div id="game-over-title">OYUN Bƒ∞TTƒ∞</div>
                <div id="final-score">Skor: 0</div>
                <button class="restart-btn" onclick="restartGame()">Tekrar Oyna</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const menuScreen = document.getElementById('menu-screen');
        const gameContainer = document.getElementById('game-container');
        const scoreDisplay = document.getElementById('score-display');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreText = document.getElementById('final-score');

        let activeGame = null;
        let gameInterval = null;
        let score = 0;
        let isGameOver = false;

        // --- ORTAK FONKSƒ∞YONLAR ---
        function startGame(gameType) {
            menuScreen.style.display = 'none';
            gameContainer.style.display = 'flex';
            activeGame = gameType;
            isGameOver = false;
            gameOverScreen.style.display = 'none';
            score = 0;
            updateScore(0);

            if (gameInterval) clearInterval(gameInterval);

            // Klavye dinleyicisini temizle ve yeniden ekle
            document.removeEventListener('keydown', handleInput);
            document.addEventListener('keydown', handleInput);

            if (gameType === 'snake') initSnake();
            if (gameType === 'tetris') initTetris();
            if (gameType === 'pacman') initPacman();
        }

        function backToMenu() {
            if (gameInterval) clearInterval(gameInterval);
            gameContainer.style.display = 'none';
            menuScreen.style.display = 'block';
            activeGame = null;
        }

        function showGameOver(finalScoreStr) {
            clearInterval(gameInterval);
            isGameOver = true;
            finalScoreText.innerText = finalScoreStr || `Skor: ${score}`;
            gameOverScreen.style.display = 'block';
        }

        function restartGame() {
            startGame(activeGame);
        }

        function updateScore(val) {
            score = val;
            // Tetris veya Yƒ±lan i√ßin farklƒ± formatlar olabilir
            if(activeGame === 'pacman') scoreDisplay.innerText = `SKOR: ${score} | CAN: ${pacmanLives}`;
            else scoreDisplay.innerText = `SKOR: ${score}`;
        }

        function handleInput(e) {
            if (isGameOver) return;
            if (activeGame === 'snake') handleSnakeInput(e);
            if (activeGame === 'tetris') handleTetrisInput(e);
            if (activeGame === 'pacman') handlePacmanInput(e);
        }

        // ==========================================
        // 1. YILAN OYUNU (Google Style - Damalƒ± Zemin)
        // ==========================================
        let snake = [];
        let apple = {};
        let snakeDir = {};
        let nextSnakeDir = {};
        const snakeGrid = 25; // Daha b√ºy√ºk bloklar
        const snakeCols = 24; // 600 / 25
        const snakeRows = 24;

        function initSnake() {
            canvas.width = 600;
            canvas.height = 600;
            snake = [{x: 10, y: 10}, {x: 9, y: 10}, {x: 8, y: 10}]; // Ba≈ülangƒ±√ß uzunluƒüu 3
            apple = spawnApple();
            snakeDir = {x: 1, y: 0};
            nextSnakeDir = {x: 1, y: 0};
            
            gameInterval = setInterval(updateSnake, 100); // Hƒ±z
        }

        function spawnApple() {
            return {
                x: Math.floor(Math.random() * snakeCols),
                y: Math.floor(Math.random() * snakeRows)
            };
        }

        function handleSnakeInput(e) {
            switch(e.key) {
                case 'ArrowUp': if(snakeDir.y === 0) nextSnakeDir = {x:0, y:-1}; break;
                case 'ArrowDown': if(snakeDir.y === 0) nextSnakeDir = {x:0, y:1}; break;
                case 'ArrowLeft': if(snakeDir.x === 0) nextSnakeDir = {x:-1, y:0}; break;
                case 'ArrowRight': if(snakeDir.x === 0) nextSnakeDir = {x:1, y:0}; break;
            }
        }

        function updateSnake() {
            snakeDir = nextSnakeDir;
            const head = {x: snake[0].x + snakeDir.x, y: snake[0].y + snakeDir.y};

            // Duvar √áarpƒ±≈ümasƒ± (√ñl√ºm)
            if (head.x < 0 || head.x >= snakeCols || head.y < 0 || head.y >= snakeRows) {
                showGameOver(`Skor: ${score}`);
                return;
            }

            // Kendine √áarpma
            for (let part of snake) {
                if (head.x === part.x && head.y === part.y) {
                    showGameOver(`Skor: ${score}`);
                    return;
                }
            }

            snake.unshift(head);

            // Elma Yeme
            if (head.x === apple.x && head.y === apple.y) {
                score++;
                updateScore(score);
                apple = spawnApple();
            } else {
                snake.pop();
            }

            drawSnakeGame();
        }

        function drawSnakeGame() {
            // 1. Damalƒ± Zemin (Google Snake Style)
            for (let r = 0; r < snakeRows; r++) {
                for (let c = 0; c < snakeCols; c++) {
                    // A√ßƒ±k ye≈üil ve koyu ye≈üil dama
                    if ((r + c) % 2 === 0) ctx.fillStyle = "#aad751"; // A√ßƒ±k
                    else ctx.fillStyle = "#a2d149"; // Koyu
                    ctx.fillRect(c * snakeGrid, r * snakeGrid, snakeGrid, snakeGrid);
                }
            }

            // 2. Elma (Kƒ±rmƒ±zƒ±)
            ctx.fillStyle = "#e7471d";
            ctx.beginPath();
            let ax = apple.x * snakeGrid + snakeGrid/2;
            let ay = apple.y * snakeGrid + snakeGrid/2;
            ctx.arc(ax, ay, snakeGrid/2 - 2, 0, Math.PI * 2);
            ctx.fill();

            // 3. Yƒ±lan (Mavi - Google Snake)
            ctx.fillStyle = "#4674E9";
            snake.forEach((part, index) => {
                // Ba≈ü kƒ±smƒ± biraz daha a√ßƒ±k veya g√∂z eklenebilir ama basit tutuyoruz
                ctx.fillRect(part.x * snakeGrid + 1, part.y * snakeGrid + 1, snakeGrid - 2, snakeGrid - 2);
                
                // G√∂zler (Sadece kafa i√ßin - index 0)
                if(index === 0) {
                    ctx.fillStyle = "white";
                    ctx.beginPath();
                    // Y√∂ne g√∂re g√∂z ayarlamak karma≈üƒ±k, sabit basit g√∂z yapalƒ±m
                    ctx.arc(part.x * snakeGrid + 8, part.y * snakeGrid + 8, 4, 0, Math.PI*2);
                    ctx.arc(part.x * snakeGrid + 18, part.y * snakeGrid + 8, 4, 0, Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle = "black";
                    ctx.beginPath();
                    ctx.arc(part.x * snakeGrid + 8, part.y * snakeGrid + 8, 2, 0, Math.PI*2);
                    ctx.arc(part.x * snakeGrid + 18, part.y * snakeGrid + 8, 2, 0, Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle = "#4674E9"; // Geri maviye d√∂n
                }
            });
        }


        // ==========================================
        // 2. TETRIS (Yan Skor + Kontroller)
        // ==========================================
        const tetrisRows = 20;
        const tetrisCols = 10;
        const tetrisSize = 30; // 300x600 canvas
        let board = [];
        let currentPiece = null;
        let dropInterval = 1000;
        let lastTime = 0;

        const PIECES = [
            [Z, "red"], [S, "green"], [T, "purple"], [O, "yellow"], [L, "orange"], [I, "cyan"], [J, "blue"]
        ];

        // Par√ßa ≈ûekilleri
        var Z = [[[1,1,0],[0,1,1],[0,0,0]]];
        var S = [[[0,1,1],[1,1,0],[0,0,0]]];
        var T = [[[0,1,0],[1,1,1],[0,0,0]]];
        var O = [[[1,1],[1,1]]];
        var L = [[[0,0,1],[1,1,1],[0,0,0]]];
        var I = [[[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]]];
        var J = [[[1,0,0],[1,1,1],[0,0,0]]];

        function initTetris() {
            canvas.width = 300; // Geni≈ülik daha dar
            canvas.height = 600;
            // Bo≈ü tahta
            board = [];
            for(let r=0; r<tetrisRows; r++){
                board[r] = [];
                for(let c=0; c<tetrisCols; c++){
                    board[r][c] = 'VACANT';
                }
            }
            dropInterval = 1000;
            spawnPiece();
            gameInterval = setInterval(updateTetris, 1000); // Ba≈ülangƒ±√ß hƒ±zƒ±
            drawTetris();
        }

        function spawnPiece() {
            let r = Math.floor(Math.random() * PIECES.length);
            // Deep copy of shape
            let shape = JSON.parse(JSON.stringify(PIECES[r][0][0])); // Basit ≈üekil al
            // I ve O gibi par√ßalar i√ßin basit mock data kullandƒ±m, tam rotasyon matrisleri uzun s√ºrer.
            // Bu √∂rnek i√ßin basit T, O, L, I tanƒ±mlarƒ±nƒ± kullanacaƒüƒ±z:
            
            // Daha d√ºzg√ºn shapes:
            const shapes = [
                [[1,1,0],[0,1,1]], // Z
                [[0,1,1],[1,1,0]], // S
                [[0,1,0],[1,1,1]], // T
                [[1,1],[1,1]],     // O
                [[1,0,0],[1,1,1]], // L
                [[1,1,1,1]],       // I (yatay ba≈ülar)
                [[0,0,1],[1,1,1]]  // J
            ];
            const colors = ["red", "green", "purple", "yellow", "orange", "cyan", "blue"];
            
            let rand = Math.floor(Math.random() * shapes.length);
            
            currentPiece = {
                matrix: shapes[rand],
                color: colors[rand],
                x: 3,
                y: 0
            };
        }

        function drawTetris() {
            // Arkaplan
            ctx.fillStyle = "#111";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Tahta
            for(let r=0; r<tetrisRows; r++){
                for(let c=0; c<tetrisCols; c++){
                    drawSquare(c, r, board[r][c]);
                }
            }

            // D√º≈üen Par√ßa
            if(currentPiece) {
                for(let r=0; r<currentPiece.matrix.length; r++){
                    for(let c=0; c<currentPiece.matrix[r].length; c++){
                        if(currentPiece.matrix[r][c]){
                            drawSquare(currentPiece.x + c, currentPiece.y + r, currentPiece.color);
                        }
                    }
                }
            }
        }

        function drawSquare(x, y, color){
            ctx.fillStyle = (color === 'VACANT') ? "#222" : color;
            ctx.fillRect(x*tetrisSize, y*tetrisSize, tetrisSize, tetrisSize);
            ctx.strokeStyle = "#333";
            ctx.strokeRect(x*tetrisSize, y*tetrisSize, tetrisSize, tetrisSize);
        }

        function handleTetrisInput(e) {
            if(!currentPiece) return;
            if(e.key === 'ArrowLeft') {
                if(!checkCollision(-1, 0, currentPiece.matrix)) currentPiece.x--;
            } else if(e.key === 'ArrowRight') {
                if(!checkCollision(1, 0, currentPiece.matrix)) currentPiece.x++;
            } else if(e.key === 'ArrowUp') {
                // D√∂nd√ºrme
                let rotated = rotate(currentPiece.matrix);
                if(!checkCollision(0, 0, rotated)) currentPiece.matrix = rotated;
            } else if(e.key === 'ArrowDown') {
                // Hƒ±zlƒ± indirme (2x deƒüil direkt hƒ±zlandƒ±rma etkisi)
                moveDown();
            }
            drawTetris();
        }

        function updateTetris() {
            moveDown();
            drawTetris();
        }

        function moveDown() {
            if(!currentPiece) return;
            if(!checkCollision(0, 1, currentPiece.matrix)) {
                currentPiece.y++;
            } else {
                // Kitle
                lockPiece();
                spawnPiece();
                // Oyun bitti mi?
                if(checkCollision(0,0, currentPiece.matrix)){
                     showGameOver(`Tetris Skor: ${score}`);
                }
            }
        }

        function lockPiece(){
            for(let r=0; r<currentPiece.matrix.length; r++){
                for(let c=0; c<currentPiece.matrix[r].length; c++){
                    if(currentPiece.matrix[r][c]){
                        // Tahta sƒ±nƒ±rlarƒ± kontrol√º
                         if(currentPiece.y + r < 0) continue;
                         board[currentPiece.y + r][currentPiece.x + c] = currentPiece.color;
                    }
                }
            }
            // Satƒ±r silme
            for(let r=0; r<tetrisRows; r++){
                let isFull = true;
                for(let c=0; c<tetrisCols; c++){
                    if(board[r][c] === 'VACANT') isFull = false;
                }
                if(isFull){
                    // Satƒ±rƒ± kaydƒ±r
                    for(let y=r; y>0; y--){
                        for(let c=0; c<tetrisCols; c++){
                            board[y][c] = board[y-1][c];
                        }
                    }
                    for(let c=0; c<tetrisCols; c++){
                        board[0][c] = 'VACANT';
                    }
                    score += 100;
                    updateScore(score);
                }
            }
        }

        function checkCollision(x, y, matrix){
            for(let r=0; r<matrix.length; r++){
                for(let c=0; c<matrix[r].length; c++){
                    if(matrix[r][c]){
                        let newX = currentPiece.x + c + x;
                        let newY = currentPiece.y + r + y;
                        if(newX < 0 || newX >= tetrisCols || newY >= tetrisRows) return true;
                        if(newY < 0) continue; 
                        if(board[newY][newX] !== 'VACANT') return true;
                    }
                }
            }
            return false;
        }

        function rotate(matrix) {
            // Transpose + Reverse
            return matrix[0].map((val, index) => matrix.map(row => row[index]).reverse());
        }

        // ==========================================
        // 3. PAC-MAN (Maze, 3 Can, Ghost)
        // ==========================================
        // Basitle≈ütirilmi≈ü Harita (1: Duvar, 0: Yem, 2: Bo≈ü, 3: Pacman)
        // 20x20 Grid
        const pacGrid = 20; 
        const pacRows = 21;
        const pacCols = 19;
        
        // Klasik haritaya benzer yapƒ±
        const mapLayout = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,1,1,1,0,1,1,1,2,1,2,1,1,1,0,1,1,1,1],
            [2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2], // T√ºnel alanƒ±
            [1,1,1,1,0,1,2,1,1,2,1,1,2,1,0,1,1,1,1],
            [1,0,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0,0,1], // Ortada hayalet evi
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,0,0,1,0,0,0,0,0,3,0,0,0,0,0,1,0,0,1],
            [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        
        let pacman = {x: 9, y: 12, dirX: 0, dirY: 0, nextDirX: 0, nextDirY: 0};
        let ghosts = [];
        let pacmanLives = 3;
        let pacMap = [];

        function initPacman() {
            // Canvas boyutunu haritaya g√∂re ayarla
            canvas.width = pacCols * 30; // 570
            canvas.height = mapLayout.length * 30; // 
            
            // Haritayƒ± kopyala
            pacMap = JSON.parse(JSON.stringify(mapLayout));
            score = 0;
            pacmanLives = 3;
            resetPositions();
            updateScore(0);

            gameInterval = setInterval(updatePacman, 150);
        }

        function resetPositions() {
            pacman = {x: 9, y: 12, dirX: 0, dirY: 0, nextDirX: 0, nextDirY: 0};
            // Basit hayaletler
            ghosts = [
                {x: 9, y: 8, color: 'red'},
                {x: 8, y: 9, color: 'pink'},
                {x: 10, y: 9, color: 'cyan'}
            ];
        }

        function handlePacmanInput(e) {
            if(e.key === 'ArrowUp') { pacman.nextDirX = 0; pacman.nextDirY = -1; }
            if(e.key === 'ArrowDown') { pacman.nextDirX = 0; pacman.nextDirY = 1; }
            if(e.key === 'ArrowLeft') { pacman.nextDirX = -1; pacman.nextDirY = 0; }
            if(e.key === 'ArrowRight') { pacman.nextDirX = 1; pacman.nextDirY = 0; }
        }

        function updatePacman() {
            // 1. Y√∂n Deƒüi≈üimi Kontrol√º (Duvar yoksa d√∂n)
            let nextX = pacman.x + pacman.nextDirX;
            let nextY = pacman.y + pacman.nextDirY;
            
            if (pacMap[nextY] && pacMap[nextY][nextX] !== 1) {
                pacman.dirX = pacman.nextDirX;
                pacman.dirY = pacman.nextDirY;
            }

            // 2. Hareket
            let moveX = pacman.x + pacman.dirX;
            let moveY = pacman.y + pacman.dirY;

            // Duvar kontrol√º
            if (pacMap[moveY] && pacMap[moveY][moveX] !== 1) {
                pacman.x = moveX;
                pacman.y = moveY;
            }

            // T√ºnel (Sol-Saƒü ge√ßi≈ü)
            if(pacman.x < 0) pacman.x = pacCols - 1;
            if(pacman.x >= pacCols) pacman.x = 0;

            // 3. Yem Yeme
            if (pacMap[pacman.y][pacman.x] === 0) {
                pacMap[pacman.y][pacman.x] = 2; // Bo≈üalt
                score += 10;
                updateScore(score);
            }

            // 4. Hayalet Hareketi (Rastgele)
            ghosts.forEach(g => {
                let directions = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}];
                let validDirs = directions.filter(d => {
                    let gx = g.x + d.x;
                    let gy = g.y + d.y;
                    // Dizi sƒ±nƒ±rlarƒ± ve Duvar kontrol√º
                    return pacMap[gy] && pacMap[gy][gx] !== 1;
                });

                if(validDirs.length > 0) {
                    let move = validDirs[Math.floor(Math.random() * validDirs.length)];
                    g.x += move.x;
                    g.y += move.y;
                }

                // √áarpƒ±≈üma Kontrol√º
                if (Math.floor(g.x) === pacman.x && Math.floor(g.y) === pacman.y) {
                    pacmanLives--;
                    updateScore(score); // Canƒ± g√ºncelle
                    if (pacmanLives <= 0) {
                        showGameOver(`Pac-Man Bitti! Skor: ${score}`);
                    } else {
                        resetPositions(); // Pozisyonlarƒ± sƒ±fƒ±rla ama yemler kalsƒ±n
                    }
                }
            });

            drawPacman();
        }

        function drawPacman() {
            let scale = 30;
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Harita √áizimi
            for (let r = 0; r < pacMap.length; r++) {
                for (let c = 0; c < pacMap[r].length; c++) {
                    let val = pacMap[r][c];
                    let px = c * scale;
                    let py = r * scale;

                    if (val === 1) {
                        // Duvar (Mavi √áizgiler)
                        ctx.strokeStyle = "#1919A6";
                        ctx.lineWidth = 2;
                        ctx.strokeRect(px + 5, py + 5, scale - 10, scale - 10);
                    } else if (val === 0) {
                        // Yem
                        ctx.fillStyle = "#ffb8ae";
                        ctx.fillRect(px + 13, py + 13, 4, 4);
                    }
                }
            }

            // Pacman √áizimi
            ctx.fillStyle = "yellow";
            ctx.beginPath();
            ctx.arc(pacman.x * scale + scale/2, pacman.y * scale + scale/2, scale/2 - 2, 0.2 * Math.PI, 1.8 * Math.PI);
            ctx.lineTo(pacman.x * scale + scale/2, pacman.y * scale + scale/2);
            ctx.fill();

            // Hayalet √áizimi
            ghosts.forEach(g => {
                ctx.fillStyle = g.color;
                ctx.beginPath();
                ctx.arc(g.x * scale + scale/2, g.y * scale + scale/2, scale/2 - 4, 0, Math.PI * 2);
                ctx.fill();
            });
        }

    </script>
</body>
</html>
