<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <title>Oyun Portalı v1.8.2</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap');

        :root {
            --primary-yellow: #ffcc00;
            --bg-dark: #121212;
            --card-bg: #1e1e1e;
        }

        body {
            margin: 0;
            background-color: var(--bg-dark);
            color: #fff;
            font-family: 'Poppins', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        /* HEADER */
        header {
            width: 100%;
            padding: 20px 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            background: #1a1a1a;
            border-bottom: 2px solid #333;
            position: relative;
            z-index: 10;
        }

        .logo {
            font-size: 24px;
            font-weight: 800;
            color: var(--primary-yellow);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-links {
            display: flex;
            gap: 20px;
            font-size: 14px;
            color: #aaa;
        }

        .nav-links span.active {
            color: var(--primary-yellow);
            font-weight: 600;
        }

        /* DÖNEN RENKLİ SÜRÜM ROZETİ */
        .version-wrapper {
            position: relative;
            padding: 2px;
            border-radius: 20px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .version-wrapper:hover { transform: scale(1.05); }

        .version-wrapper::before {
            content: '';
            position: absolute;
            top: -50%; left: -50%;
            width: 200%; height: 200%;
            background: conic-gradient(#ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #8f00ff, #ff0000);
            animation: rotateBorder 2s linear infinite;
            z-index: 0;
        }

        @keyframes rotateBorder { 100% { transform: rotate(360deg); } }

        .version-badge {
            position: relative;
            background: #000;
            padding: 5px 15px;
            border-radius: 18px;
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            z-index: 1;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* MENÜ */
        #menu-screen {
            text-align: center;
            margin-top: 50px;
            animation: fadeIn 0.5s;
        }

        h2.section-title { font-size: 28px; margin-bottom: 30px; }

        .games-grid {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .game-card {
            background: var(--card-bg);
            border: 1px solid #333;
            border-radius: 15px;
            width: 280px;
            padding: 40px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        .game-card:hover {
            transform: translateY(-5px);
            border-color: var(--primary-yellow);
            box-shadow: 0 0 15px rgba(255, 204, 0, 0.2);
        }

        .game-icon svg {
            width: 60px; height: 60px;
            fill: none; stroke: var(--primary-yellow); stroke-width: 3;
            stroke-linecap: round; stroke-linejoin: round;
        }
        .game-icon.fill svg { fill: var(--primary-yellow); stroke: none; }

        .game-title { font-weight: 700; font-size: 20px; }
        .game-desc { font-size: 13px; color: #888; }

        /* OYUN ALANI */
        #game-container {
            display: none;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            width: 100%;
        }

        .game-header {
            display: flex; justify-content: space-between;
            width: 600px; margin-bottom: 10px; align-items: center;
        }

        .back-btn {
            background: #333; border: none; color: white;
            padding: 8px 16px; border-radius: 5px; cursor: pointer;
        }
        .back-btn:hover { background: #444; }

        canvas {
            background: #000; border: 2px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.5); display: block;
        }

        /* MODAL */
        .modal-overlay {
            display: none; position: fixed; top: 0; left: 0;
            width: 100%; height: 100%; background: rgba(0,0,0,0.8);
            z-index: 100; justify-content: center; align-items: center;
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background: #1a1a1a; width: 500px; max-height: 80vh;
            border-radius: 15px; border: 1px solid #444; padding: 30px;
            overflow-y: auto; position: relative;
        }
        .changelog-item { margin-bottom: 20px; }
        .version-title { color: var(--primary-yellow); font-weight: bold; margin-bottom: 5px; }
        .change-list { list-style: none; padding: 0; margin: 0; font-size: 13px; color: #ccc; }
        .change-list li::before { content: '•'; color: #555; position: absolute; left: 0; }
        .change-list li { margin-bottom: 5px; padding-left: 15px; position: relative; }
        .close-modal { background: none; border: none; color: #888; font-size: 24px; cursor: pointer; float: right; }

        /* GAME OVER */
        #game-over-screen {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95); padding: 40px;
            border-radius: 15px; text-align: center; display: none;
            border: 2px solid var(--primary-yellow); z-index: 50;
        }
        .restart-btn {
            background: #2196F3; color: white; border: none;
            padding: 10px 20px; font-size: 16px; border-radius: 5px;
            cursor: pointer; margin-top: 15px;
        }
    </style>
</head>
<body>

    <header>
        <div class="logo">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#ffcc00" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="6" width="20" height="12" rx="2"></rect><path d="M6 12h4m-2-2v4"></path><line x1="15" y1="11" x2="15" y2="11"></line><line x1="18" y1="13" x2="18" y2="13"></line></svg>
            OYUN PORTALI
        </div>
        <div class="nav-links">
            <span>Anasayfa</span>
            <span class="active">Oyunlar</span>
            <span>Ders Notları</span>
            <span>Filmler</span>
        </div>
        <div class="version-wrapper" onclick="openChangelog()">
            <div class="version-badge">v1.8.2 <span>ℹ</span></div>
        </div>
    </header>

    <div id="changelog-modal" class="modal-overlay">
        <div class="modal-content">
            <button class="close-modal" onclick="closeChangelog()">×</button>
            <h3 style="margin-top:0">Sürüm Geçmişi</h3>
            
            <div class="changelog-item">
                <div class="version-title">v1.8.2 (Güncel)</div>
                <ul class="change-list">
                    <li>Tetris bloklarının gelmeme sorunu düzeltildi.</li>
                    <li>Pac-Man'de hayalet sayısı 1'e indirildi.</li>
                    <li>Hayalet Yapay Zekası: Artık seni takip ediyor!</li>
                </ul>
            </div>
            <div class="changelog-item">
                <div class="version-title">v1.8.1</div>
                <ul class="change-list">
                    <li>Vektörel SVG ikonlar ve RGB dönen çerçeve eklendi.</li>
                </ul>
            </div>
        </div>
    </div>

    <div id="menu-screen">
        <h2 class="section-title">Oyun Kütüphanesi</h2>
        <div class="games-grid">
            <div class="game-card" onclick="startGame('snake')">
                <div class="game-icon">
                    <svg viewBox="0 0 24 24"><path d="M7 4v2a2 2 0 0 1-2 2H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2a2 2 0 0 1 2 2v2" stroke="#ffcc00"></path><circle cx="8" cy="4" r="2" fill="#ffcc00" stroke="none"></circle></svg>
                </div>
                <div class="game-title">Yılan Oyunu</div>
                <div class="game-desc">Google Snake tarzı damalı zemin.</div>
            </div>

            <div class="game-card" onclick="startGame('tetris')">
                <div class="game-icon fill">
                    <svg viewBox="0 0 24 24"><rect x="2" y="2" width="9" height="9" rx="1"></rect><rect x="13" y="2" width="9" height="9" rx="1"></rect><rect x="2" y="13" width="9" height="9" rx="1"></rect><rect x="13" y="13" width="9" height="9" rx="1"></rect></svg>
                </div>
                <div class="game-title">Tetris</div>
                <div class="game-desc">Blokları yerleştir, satırları yok et.</div>
            </div>

            <div class="game-card" onclick="startGame('pacman')">
                <div class="game-icon fill">
                    <svg viewBox="0 0 24 24"><path d="M12 2a8 8 0 0 0-8 8v10a2 2 0 0 0 2 2c.5 0 1-.5 1.5-1s1 1 1.5 1 1.5-1 1.5-1 1.5 1 1.5-1 1.5-1 2-2V10a8 8 0 0 0-8-8z"></path><circle cx="9" cy="9" r="1.5" fill="#000"></circle><circle cx="15" cy="9" r="1.5" fill="#000"></circle></svg>
                </div>
                <div class="game-title">Pac-Man</div>
                <div class="game-desc">1 Akıllı Hayalet, 3 Can Hakkı.</div>
            </div>
        </div>
    </div>

    <div id="game-container">
        <div class="game-header">
            <button class="back-btn" onclick="backToMenu()">← Menü</button>
            <div id="score-display" style="font-weight:bold; color:#ffcc00; font-size:18px;">SKOR: 0</div>
        </div>
        <div style="position: relative;">
            <canvas id="gameCanvas" width="600" height="600"></canvas>
            <div id="game-over-screen">
                <div style="color: #ff4444; font-size: 32px; font-weight: bold; margin-bottom: 10px;">OYUN BİTTİ</div>
                <div id="final-score" style="font-size: 24px; color: #fff;">Skor: 0</div>
                <button class="restart-btn" onclick="restartGame()">Tekrar Oyna</button>
            </div>
        </div>
    </div>

    <script>
        // MODAL
        function openChangelog() { document.getElementById('changelog-modal').style.display = 'flex'; }
        function closeChangelog() { document.getElementById('changelog-modal').style.display = 'none'; }
        window.onclick = function(e) { if(e.target == document.getElementById('changelog-modal')) closeChangelog(); }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const menuScreen = document.getElementById('menu-screen');
        const gameContainer = document.getElementById('game-container');
        const scoreDisplay = document.getElementById('score-display');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreText = document.getElementById('final-score');

        let activeGame = null;
        let gameInterval = null;
        let score = 0;
        let isGameOver = false;

        function startGame(type) {
            menuScreen.style.display = 'none';
            gameContainer.style.display = 'flex';
            activeGame = type;
            isGameOver = false;
            gameOverScreen.style.display = 'none';
            score = 0;
            updateScore(0);
            if(gameInterval) clearInterval(gameInterval);
            
            // Klavye olaylarını temizle ve yeniden bağla
            document.onkeydown = null;
            document.onkeydown = handleInput;

            if(type === 'snake') initSnake();
            if(type === 'tetris') initTetris();
            if(type === 'pacman') initPacman();
        }

        function backToMenu() {
            if(gameInterval) clearInterval(gameInterval);
            gameContainer.style.display = 'none';
            menuScreen.style.display = 'block';
            activeGame = null;
        }

        function showGameOver(text) {
            clearInterval(gameInterval);
            isGameOver = true;
            finalScoreText.innerText = text || `Skor: ${score}`;
            gameOverScreen.style.display = 'block';
        }

        function restartGame() { startGame(activeGame); }

        function updateScore(val) {
            score = val;
            if(activeGame === 'pacman') scoreDisplay.innerText = `SKOR: ${score} | CAN: ${pacmanLives}`;
            else scoreDisplay.innerText = `SKOR: ${score}`;
        }

        function handleInput(e) {
            if(isGameOver) return;
            // Scroll engelle
            if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.code)) e.preventDefault();
            
            if(activeGame === 'snake') handleSnakeInput(e);
            if(activeGame === 'tetris') handleTetrisInput(e);
            if(activeGame === 'pacman') handlePacmanInput(e);
        }

        // ======================== YILAN (SNAKE) ========================
        let snake=[], apple={}, snakeDir={}, nextSnakeDir={};
        const sGrid=25, sCols=24, sRows=24;

        function initSnake() {
            canvas.width = 600; canvas.height = 600;
            snake = [{x:10,y:10}, {x:9,y:10}, {x:8,y:10}];
            snakeDir = {x:1, y:0}; nextSnakeDir = {x:1, y:0};
            apple = spawnApple();
            gameInterval = setInterval(updateSnake, 100);
        }

        function spawnApple() { return {x: Math.floor(Math.random()*sCols), y: Math.floor(Math.random()*sRows)}; }

        function handleSnakeInput(e) {
            if(e.key==='ArrowUp' && snakeDir.y===0) nextSnakeDir={x:0, y:-1};
            if(e.key==='ArrowDown' && snakeDir.y===0) nextSnakeDir={x:0, y:1};
            if(e.key==='ArrowLeft' && snakeDir.x===0) nextSnakeDir={x:-1, y:0};
            if(e.key==='ArrowRight' && snakeDir.x===0) nextSnakeDir={x:1, y:0};
        }

        function updateSnake() {
            snakeDir = nextSnakeDir;
            let head = {x: snake[0].x + snakeDir.x, y: snake[0].y + snakeDir.y};

            if(head.x<0 || head.x>=sCols || head.y<0 || head.y>=sRows) return showGameOver();
            if(snake.some(p => p.x===head.x && p.y===head.y)) return showGameOver();

            snake.unshift(head);
            if(head.x===apple.x && head.y===apple.y) {
                score++; updateScore(score); apple = spawnApple();
            } else snake.pop();

            // Çizim
            for(let r=0; r<sRows; r++) {
                for(let c=0; c<sCols; c++) {
                    ctx.fillStyle = (r+c)%2===0 ? "#aad751" : "#a2d149";
                    ctx.fillRect(c*sGrid, r*sGrid, sGrid, sGrid);
                }
            }
            ctx.fillStyle="#e7471d";
            ctx.beginPath(); ctx.arc(apple.x*sGrid+sGrid/2, apple.y*sGrid+sGrid/2, sGrid/2-2, 0, Math.PI*2); ctx.fill();
            
            ctx.fillStyle="#4674E9";
            snake.forEach(p => ctx.fillRect(p.x*sGrid+1, p.y*sGrid+1, sGrid-2, sGrid-2));
        }

        // ======================== TETRIS (DÜZELTİLDİ) ========================
        const tRows=20, tCols=10, tSize=30;
        let board=[], currentPiece=null;
        
        // Parçalar (Matris ve Renk)
        const TETROMINOS = [
            { matrix: [[1,1,1,1]], color: "cyan" }, // I
            { matrix: [[1,1],[1,1]], color: "yellow" }, // O
            { matrix: [[0,1,0],[1,1,1]], color: "purple" }, // T
            { matrix: [[0,1,1],[1,1,0]], color: "green" }, // S
            { matrix: [[1,1,0],[0,1,1]], color: "red" }, // Z
            { matrix: [[1,0,0],[1,1,1]], color: "blue" }, // J
            { matrix: [[0,0,1],[1,1,1]], color: "orange" } // L
        ];

        function initTetris() {
            canvas.width = 300; canvas.height = 600;
            board = Array.from({length: tRows}, () => Array(tCols).fill(null));
            score = 0;
            spawnTetrisPiece();
            gameInterval = setInterval(updateTetris, 1000);
            drawTetris();
        }

        function spawnTetrisPiece() {
            const r = Math.floor(Math.random() * TETROMINOS.length);
            const pieceData = TETROMINOS[r];
            
            // DERİN KOPYA (Deep Copy) - Çok Önemli!
            // Matrisin referansını değil kopyasını alıyoruz, böylece döndürdüğümüzde ana dizi bozulmuyor.
            const matrixCopy = JSON.parse(JSON.stringify(pieceData.matrix));

            currentPiece = {
                matrix: matrixCopy,
                color: pieceData.color,
                x: 3,
                y: 0 // En üstten başla
            };

            // Eğer doğduğu anda çarpıyorsa oyun bitti
            if (checkCollision(0, 0, currentPiece.matrix)) {
                showGameOver(`Tetris Bitti! Skor: ${score}`);
            }
        }

        function updateTetris() {
            moveTetrisDown();
            drawTetris();
        }

        function moveTetrisDown() {
            if(!currentPiece) return;
            if(!checkCollision(0, 1, currentPiece.matrix)) {
                currentPiece.y++;
            } else {
                lockTetrisPiece();
                spawnTetrisPiece();
            }
        }

        function handleTetrisInput(e) {
            if(!currentPiece || isGameOver) return;
            
            if(e.key === 'ArrowLeft') {
                if(!checkCollision(-1, 0, currentPiece.matrix)) currentPiece.x--;
            } else if(e.key === 'ArrowRight') {
                if(!checkCollision(1, 0, currentPiece.matrix)) currentPiece.x++;
            } else if(e.key === 'ArrowDown') {
                moveTetrisDown();
            } else if(e.key === 'ArrowUp') {
                // Döndürme
                const rotated = currentPiece.matrix[0].map((_, i) => currentPiece.matrix.map(row => row[i]).reverse());
                if(!checkCollision(0, 0, rotated)) {
                    currentPiece.matrix = rotated;
                }
            }
            drawTetris();
        }

        function checkCollision(offX, offY, matrix) {
            for(let r=0; r<matrix.length; r++){
                for(let c=0; c<matrix[r].length; c++){
                    if(matrix[r][c]){
                        let newX = currentPiece.x + c + offX;
                        let newY = currentPiece.y + r + offY;
                        
                        if(newX < 0 || newX >= tCols || newY >= tRows) return true; 
                        if(newY < 0) continue; // Ekranın üstünde ise çarpma sayma
                        if(board[newY][newX]) return true;
                    }
                }
            }
            return false;
        }

        function lockTetrisPiece() {
            currentPiece.matrix.forEach((row, r) => {
                row.forEach((val, c) => {
                    if(val) {
                        let by = currentPiece.y + r;
                        let bx = currentPiece.x + c;
                        if(by >= 0) board[by][bx] = currentPiece.color;
                    }
                });
            });

            // Satır Silme
            for(let r=0; r<tRows; r++) {
                if(board[r].every(cell => cell !== null)) {
                    board.splice(r, 1);
                    board.unshift(Array(tCols).fill(null));
                    score += 100;
                    updateScore(score);
                }
            }
        }

        function drawTetris() {
            ctx.fillStyle = "#111"; ctx.fillRect(0,0,canvas.width, canvas.height);
            
            // Yerleşmiş Bloklar
            for(let r=0; r<tRows; r++) {
                for(let c=0; c<tCols; c++) {
                    if(board[r][c]) drawBlock(c, r, board[r][c]);
                }
            }
            
            // Aktif Parça
            if(currentPiece) {
                currentPiece.matrix.forEach((row, r) => {
                    row.forEach((val, c) => {
                        if(val) drawBlock(currentPiece.x+c, currentPiece.y+r, currentPiece.color);
                    });
                });
            }
        }

        function drawBlock(x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x*tSize, y*tSize, tSize, tSize);
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.strokeRect(x*tSize, y*tSize, tSize, tSize);
        }

        // ======================== PACMAN (1 HAYALET + TAKİP) ========================
        const pGrid = 20, pCols = 19;
        const pMapLayout = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,1,1,1,0,1,1,1,2,1,2,1,1,1,0,1,1,1,1],
            [2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2],
            [1,1,1,1,0,1,2,1,1,2,1,1,2,1,0,1,1,1,1],
            [1,0,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0,0,1], 
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,0,0,1,0,0,0,0,0,3,0,0,0,0,0,1,0,0,1],
            [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        
        let pacman={}, ghost={}, pacmanLives=3, pacMap=[];

        function initPacman() {
            canvas.width = pCols * 30; canvas.height = pMapLayout.length * 30;
            pacMap = JSON.parse(JSON.stringify(pMapLayout));
            score=0; pacmanLives=3;
            resetPacPositions();
            updateScore(0);
            gameInterval = setInterval(updatePacman, 150);
        }

        function resetPacPositions() {
            pacman = {x: 9, y: 12, dirX:0, dirY:0, nextDirX:0, nextDirY:0};
            // TEK HAYALET (Kırmızı)
            ghost = {x: 9, y: 8, color: 'red'};
        }

        function handlePacmanInput(e) {
            if(e.key==='ArrowUp') { pacman.nextDirX=0; pacman.nextDirY=-1; }
            if(e.key==='ArrowDown') { pacman.nextDirX=0; pacman.nextDirY=1; }
            if(e.key==='ArrowLeft') { pacman.nextDirX=-1; pacman.nextDirY=0; }
            if(e.key==='ArrowRight') { pacman.nextDirX=1; pacman.nextDirY=0; }
        }

        function updatePacman() {
            // Pacman Yön Değiştirme
            let nextX = pacman.x + pacman.nextDirX;
            let nextY = pacman.y + pacman.nextDirY;
            if(pacMap[nextY] && pacMap[nextY][nextX] !== 1) {
                pacman.dirX = pacman.nextDirX; pacman.dirY = pacman.nextDirY;
            }

            // Pacman Hareket
            let moveX = pacman.x + pacman.dirX;
            let moveY = pacman.y + pacman.dirY;
            if(pacMap[moveY] && pacMap[moveY][moveX] !== 1) {
                pacman.x = moveX; pacman.y = moveY;
            }

            // Tünel
            if(pacman.x < 0) pacman.x = pCols-1;
            if(pacman.x >= pCols) pacman.x = 0;

            // Yem
            if(pacMap[pacman.y][pacman.x] === 0) {
                pacMap[pacman.y][pacman.x] = 2; score+=10; updateScore(score);
            }

            // --- HAYALET YAPAY ZEKASI (TAKİP) ---
            // Hedef: Pacman'in konumu
            // Basit yol bulma: Pacman'e olan mesafeyi azaltan geçerli kareye git.
            
            let possibleMoves = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}];
            let bestMove = null;
            let minDistance = 9999;

            // O anki geçerli hamleleri bul
            let validMoves = possibleMoves.filter(m => {
                let gx = ghost.x + m.x;
                let gy = ghost.y + m.y;
                // Duvar değilse
                return pacMap[gy] && pacMap[gy][gx] !== 1;
            });

            // En iyi hamleyi seç (Mesafeyi ölçerek)
            validMoves.forEach(m => {
                let gx = ghost.x + m.x;
                let gy = ghost.y + m.y;
                // Manhattan Distance (Basit mesafe hesaplama)
                let dist = Math.abs(gx - pacman.x) + Math.abs(gy - pacman.y);
                
                if (dist < minDistance) {
                    minDistance = dist;
                    bestMove = m;
                }
            });

            // Hareket et
            if (bestMove) {
                ghost.x += bestMove.x;
                ghost.y += bestMove.y;
            }

            // Çarpışma
            if(ghost.x === pacman.x && ghost.y === pacman.y) {
                pacmanLives--; updateScore(score);
                if(pacmanLives<=0) showGameOver();
                else resetPacPositions();
            }

            drawPacman();
        }

        function drawPacman() {
            let s = 30;
            ctx.fillStyle="black"; ctx.fillRect(0,0,canvas.width,canvas.height);
            
            // Harita
            for(let r=0; r<pacMap.length; r++) for(let c=0; c<pacMap[r].length; c++){
                if(pacMap[r][c]===1) {
                    ctx.strokeStyle="#1919A6"; ctx.lineWidth=2; ctx.strokeRect(c*s+5,r*s+5,s-10,s-10);
                } else if(pacMap[r][c]===0) {
                    ctx.fillStyle="#ffb8ae"; ctx.fillRect(c*s+13,r*s+13,4,4);
                }
            }
            
            // Pacman
            ctx.fillStyle="yellow"; ctx.beginPath();
            ctx.arc(pacman.x*s+s/2, pacman.y*s+s/2, s/2-2, 0.2*Math.PI, 1.8*Math.PI);
            ctx.lineTo(pacman.x*s+s/2, pacman.y*s+s/2); ctx.fill();

            // Hayalet (Kırmızı)
            ctx.fillStyle=ghost.color; ctx.beginPath();
            ctx.arc(ghost.x*s+s/2, ghost.y*s+s/2, s/2-4, 0, Math.PI*2); ctx.fill();
        }
    </script>
</body>
</html>
