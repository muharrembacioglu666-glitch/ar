<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <title>Oyun Portalı v1.8.1</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap');

        :root {
            --primary-yellow: #ffcc00;
            --bg-dark: #121212;
            --card-bg: #1e1e1e;
        }

        body {
            margin: 0;
            background-color: var(--bg-dark);
            color: #fff;
            font-family: 'Poppins', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        /* HEADER */
        header {
            width: 100%;
            padding: 20px 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            background: #1a1a1a;
            border-bottom: 2px solid #333;
            position: relative;
            z-index: 10;
        }

        .logo {
            font-size: 24px;
            font-weight: 800;
            color: var(--primary-yellow);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-links {
            display: flex;
            gap: 20px;
            font-size: 14px;
            color: #aaa;
        }

        .nav-links span.active {
            color: var(--primary-yellow);
            font-weight: 600;
        }

        /* DÖNEN RENKLİ SÜRÜM ROZETİ */
        .version-wrapper {
            position: relative;
            padding: 2px; /* Çerçevenin kalınlığı */
            border-radius: 20px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .version-wrapper:hover {
            transform: scale(1.05);
        }

        .version-wrapper::before {
            content: '';
            position: absolute;
            top: -50%; left: -50%;
            width: 200%; height: 200%;
            background: conic-gradient(
                #ff0000, #ff7f00, #ffff00, #00ff00, 
                #0000ff, #4b0082, #8f00ff, #ff0000
            );
            animation: rotateBorder 2s linear infinite;
            z-index: 0;
        }

        @keyframes rotateBorder {
            100% { transform: rotate(360deg); }
        }

        .version-badge {
            position: relative;
            background: #000;
            padding: 5px 15px;
            border-radius: 18px;
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            z-index: 1;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* MENU EKRANI */
        #menu-screen {
            text-align: center;
            margin-top: 50px;
            animation: fadeIn 0.5s;
        }

        h2.section-title {
            margin-bottom: 30px;
            font-size: 28px;
        }

        .games-grid {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .game-card {
            background: var(--card-bg);
            border: 1px solid #333;
            border-radius: 15px;
            width: 280px;
            padding: 40px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        .game-card:hover {
            transform: translateY(-5px);
            border-color: var(--primary-yellow);
            box-shadow: 0 0 15px rgba(255, 204, 0, 0.2);
        }

        /* SVG İKONLAR */
        .game-icon svg {
            width: 60px;
            height: 60px;
            fill: none;
            stroke: var(--primary-yellow);
            stroke-width: 3;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        
        /* Pacman ve Tetris için dolgu ayarları */
        .game-icon.fill svg {
            fill: var(--primary-yellow);
            stroke: none;
        }

        .game-title {
            font-weight: 700;
            font-size: 20px;
            color: #fff;
        }

        .game-desc {
            font-size: 13px;
            color: #888;
            line-height: 1.5;
        }

        /* OYUN ALANI */
        #game-container {
            display: none;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            width: 100%;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            width: 600px;
            margin-bottom: 10px;
            align-items: center;
        }

        .back-btn {
            background: #333;
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
        }
        .back-btn:hover { background: #444; }

        canvas {
            background: #000;
            border: 2px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            display: block;
        }

        /* MODAL (CHANGELOG) */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 100;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: #1a1a1a;
            width: 500px;
            max-height: 80vh;
            border-radius: 15px;
            border: 1px solid #444;
            padding: 30px;
            position: relative;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #333;
            padding-bottom: 15px;
        }

        .close-modal {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
        }
        .close-modal:hover { color: #fff; }

        .changelog-item {
            margin-bottom: 20px;
        }
        .version-title {
            color: var(--primary-yellow);
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        .change-list {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: 13px;
            color: #ccc;
        }
        .change-list li {
            margin-bottom: 5px;
            padding-left: 15px;
            position: relative;
        }
        .change-list li::before {
            content: '•';
            color: #555;
            position: absolute;
            left: 0;
        }

        /* GAME OVER */
        #game-over-screen {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            display: none;
            border: 2px solid var(--primary-yellow);
            z-index: 50;
        }
        .restart-btn {
            background: #2196F3;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 15px;
        }
    </style>
</head>
<body>

    <header>
        <div class="logo">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#ffcc00" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="2" y="6" width="20" height="12" rx="2"></rect>
                <path d="M6 12h4m-2-2v4"></path>
                <line x1="15" y1="11" x2="15" y2="11"></line>
                <line x1="18" y1="13" x2="18" y2="13"></line>
            </svg>
            OYUN PORTALI
        </div>
        <div class="nav-links">
            <span>Anasayfa</span>
            <span class="active">Oyunlar</span>
            <span>Ders Notları</span>
            <span>Filmler</span>
        </div>
        <div class="version-wrapper" onclick="openChangelog()">
            <div class="version-badge">
                v1.8.1 <span style="font-size:10px">ℹ</span>
            </div>
        </div>
    </header>

    <div id="changelog-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3 style="margin:0">Sürüm Geçmişi</h3>
                <button class="close-modal" onclick="closeChangelog()">×</button>
            </div>
            
            <div class="changelog-item">
                <div class="version-title">v1.8.1 (Güncel)</div>
                <ul class="change-list">
                    <li>Arayüz ikonları tamamen yenilendi (SVG Grafik).</li>
                    <li>Sürüm rozetine RGB dönen animasyon eklendi.</li>
                    <li>Sürüm geçmişi (bu pencere) özelliği eklendi.</li>
                </ul>
            </div>

            <div class="changelog-item">
                <div class="version-title">v1.8.0</div>
                <ul class="change-list">
                    <li>Pac-Man haritası klasik arcade labirente dönüştürüldü.</li>
                    <li>Pac-Man'e 3 can hakkı ve hayalet mekaniği eklendi.</li>
                    <li>Tetris kontrolleri geliştirildi (Yukarı ok ile döndürme).</li>
                    <li>Yılan Oyunu zemini "Damalı Yeşil" (Google Style) yapıldı.</li>
                </ul>
            </div>

            <div class="changelog-item">
                <div class="version-title">v1.7.0</div>
                <ul class="change-list">
                    <li>Oyunlar tek bir portal altında birleştirildi.</li>
                    <li>Ana menü tasarımı karanlık moda uyarlandı.</li>
                </ul>
            </div>
             <div class="changelog-item">
                <div class="version-title">v1.0.0 - v1.6.0</div>
                <ul class="change-list">
                    <li>İlk prototipler (Sadece Yılan oyunu vardı).</li>
                    <li>Basit skor tablosu denemeleri.</li>
                    <li>Hata düzeltmeleri.</li>
                </ul>
            </div>
        </div>
    </div>

    <div id="menu-screen">
        <h2 class="section-title">Oyun Kütüphanesi</h2>
        <div class="games-grid">
            <div class="game-card" onclick="startGame('snake')">
                <div class="game-icon">
                    <svg viewBox="0 0 24 24">
                        <path d="M7 4v2a2 2 0 0 1-2 2H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2a2 2 0 0 1 2 2v2" stroke="#ffcc00"></path>
                        <circle cx="8" cy="4" r="2" fill="#ffcc00" stroke="none"></circle>
                    </svg>
                </div>
                <div class="game-title">Yılan Oyunu</div>
                <div class="game-desc">Duvarlara çarpma, elmaları topla!</div>
            </div>

            <div class="game-card" onclick="startGame('tetris')">
                <div class="game-icon fill">
                    <svg viewBox="0 0 24 24">
                        <rect x="2" y="2" width="9" height="9" rx="1"></rect>
                        <rect x="13" y="2" width="9" height="9" rx="1"></rect>
                        <rect x="2" y="13" width="9" height="9" rx="1"></rect>
                        <rect x="13" y="13" width="9" height="9" rx="1"></rect>
                    </svg>
                </div>
                <div class="game-title">Tetris</div>
                <div class="game-desc">Tam fonksiyonlu: Çevir, Kaydır, Patlat.</div>
            </div>

            <div class="game-card" onclick="startGame('pacman')">
                <div class="game-icon fill">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 2a8 8 0 0 0-8 8v10a2 2 0 0 0 2 2c.5 0 1-.5 1.5-1s1 1 1.5 1 1.5-1 1.5-1 1.5 1 1.5 1 1.5-1 1.5-1 2-2V10a8 8 0 0 0-8-8z"></path>
                        <circle cx="9" cy="9" r="1.5" fill="#000"></circle>
                        <circle cx="15" cy="9" r="1.5" fill="#000"></circle>
                    </svg>
                </div>
                <div class="game-title">Pac-Man</div>
                <div class="game-desc">3 Can Hakkı, Arcade Labirent.</div>
            </div>
        </div>
    </div>

    <div id="game-container">
        <div class="game-header">
            <button class="back-btn" onclick="backToMenu()">← Menü</button>
            <div id="score-display" style="font-weight:bold; color:#ffcc00; font-size:18px;">SKOR: 0</div>
        </div>
        
        <div style="position: relative;">
            <canvas id="gameCanvas" width="600" height="600"></canvas>
            
            <div id="game-over-screen">
                <div style="color: #ff4444; font-size: 32px; font-weight: bold; margin-bottom: 10px;">OYUN BİTTİ</div>
                <div id="final-score" style="font-size: 24px; color: #fff;">Skor: 0</div>
                <button class="restart-btn" onclick="restartGame()">Tekrar Oyna</button>
            </div>
        </div>
    </div>

    <script>
        // --- CHANGELOG MODAL ---
        function openChangelog() {
            document.getElementById('changelog-modal').style.display = 'flex';
        }
        function closeChangelog() {
            document.getElementById('changelog-modal').style.display = 'none';
        }
        // Modal dışına tıklayınca kapatma
        window.onclick = function(event) {
            const modal = document.getElementById('changelog-modal');
            if (event.target == modal) {
                modal.style.display = "none";
            }
        }

        // --- OYUN MEKANİKLERİ ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const menuScreen = document.getElementById('menu-screen');
        const gameContainer = document.getElementById('game-container');
        const scoreDisplay = document.getElementById('score-display');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreText = document.getElementById('final-score');

        let activeGame = null;
        let gameInterval = null;
        let score = 0;
        let isGameOver = false;

        function startGame(gameType) {
            menuScreen.style.display = 'none';
            gameContainer.style.display = 'flex';
            activeGame = gameType;
            isGameOver = false;
            gameOverScreen.style.display = 'none';
            score = 0;
            updateScore(0);
            if (gameInterval) clearInterval(gameInterval);
            document.removeEventListener('keydown', handleInput);
            document.addEventListener('keydown', handleInput);

            if (gameType === 'snake') initSnake();
            if (gameType === 'tetris') initTetris();
            if (gameType === 'pacman') initPacman();
        }

        function backToMenu() {
            if (gameInterval) clearInterval(gameInterval);
            gameContainer.style.display = 'none';
            menuScreen.style.display = 'block';
            activeGame = null;
        }

        function showGameOver(finalScoreStr) {
            clearInterval(gameInterval);
            isGameOver = true;
            finalScoreText.innerText = finalScoreStr || `Skor: ${score}`;
            gameOverScreen.style.display = 'block';
        }

        function restartGame() {
            startGame(activeGame);
        }

        function updateScore(val) {
            score = val;
            if(activeGame === 'pacman') scoreDisplay.innerText = `SKOR: ${score} | CAN: ${pacmanLives}`;
            else scoreDisplay.innerText = `SKOR: ${score}`;
        }

        function handleInput(e) {
            if (isGameOver) return;
            // Kaydırma engelleme (ok tuşları)
            if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
                e.preventDefault();
            }
            if (activeGame === 'snake') handleSnakeInput(e);
            if (activeGame === 'tetris') handleTetrisInput(e);
            if (activeGame === 'pacman') handlePacmanInput(e);
        }

        // ======================== YILAN ========================
        let snake = [], apple = {}, snakeDir = {}, nextSnakeDir = {};
        const snakeGrid = 25, snakeCols = 24, snakeRows = 24;

        function initSnake() {
            canvas.width = 600; canvas.height = 600;
            snake = [{x: 10, y: 10}, {x: 9, y: 10}, {x: 8, y: 10}];
            apple = spawnApple();
            snakeDir = {x: 1, y: 0}; nextSnakeDir = {x: 1, y: 0};
            gameInterval = setInterval(updateSnake, 100);
        }
        function spawnApple() {
            return { x: Math.floor(Math.random() * snakeCols), y: Math.floor(Math.random() * snakeRows) };
        }
        function handleSnakeInput(e) {
            switch(e.key) {
                case 'ArrowUp': if(snakeDir.y===0) nextSnakeDir={x:0, y:-1}; break;
                case 'ArrowDown': if(snakeDir.y===0) nextSnakeDir={x:0, y:1}; break;
                case 'ArrowLeft': if(snakeDir.x===0) nextSnakeDir={x:-1, y:0}; break;
                case 'ArrowRight': if(snakeDir.x===0) nextSnakeDir={x:1, y:0}; break;
            }
        }
        function updateSnake() {
            snakeDir = nextSnakeDir;
            const head = {x: snake[0].x + snakeDir.x, y: snake[0].y + snakeDir.y};
            if (head.x < 0 || head.x >= snakeCols || head.y < 0 || head.y >= snakeRows) return showGameOver();
            for (let part of snake) if (head.x === part.x && head.y === part.y) return showGameOver();
            snake.unshift(head);
            if (head.x === apple.x && head.y === apple.y) {
                score++; updateScore(score); apple = spawnApple();
            } else snake.pop();
            
            // Çizim
            for (let r=0; r<snakeRows; r++) {
                for (let c=0; c<snakeCols; c++) {
                    ctx.fillStyle = (r+c)%2===0 ? "#aad751" : "#a2d149";
                    ctx.fillRect(c*snakeGrid, r*snakeGrid, snakeGrid, snakeGrid);
                }
            }
            ctx.fillStyle = "#e7471d";
            ctx.beginPath();
            ctx.arc(apple.x*snakeGrid+snakeGrid/2, apple.y*snakeGrid+snakeGrid/2, snakeGrid/2-2, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = "#4674E9";
            snake.forEach(p => ctx.fillRect(p.x*snakeGrid+1, p.y*snakeGrid+1, snakeGrid-2, snakeGrid-2));
        }

        // ======================== TETRIS ========================
        const tetrisRows=20, tetrisCols=10, tetrisSize=30;
        let board=[], currentPiece=null;
        const PIECES = [
            [[[1,1,0],[0,1,1]], "red"], [[[0,1,1],[1,1,0]], "green"], 
            [[[0,1,0],[1,1,1]], "purple"], [[[1,1],[1,1]], "yellow"], 
            [[[0,0,1],[1,1,1]], "orange"], [[[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]], "cyan"], 
            [[[1,0,0],[1,1,1]], "blue"]
        ];

        function initTetris() {
            canvas.width = 300; canvas.height = 600;
            board = Array.from({length: tetrisRows}, () => Array(tetrisCols).fill(null));
            spawnPiece();
            gameInterval = setInterval(updateTetris, 1000);
            drawTetris();
        }
        function spawnPiece() {
            let r = Math.floor(Math.random() * PIECES.length);
            currentPiece = { matrix: PIECES[r][0], color: PIECES[r][1], x: 3, y: 0 };
        }
        function updateTetris() {
            moveDown(); drawTetris();
        }
        function moveDown() {
            if(!currentPiece) return;
            if(!checkCollision(0, 1, currentPiece.matrix)) currentPiece.y++;
            else {
                lockPiece(); spawnPiece();
                if(checkCollision(0,0, currentPiece.matrix)) showGameOver();
            }
        }
        function handleTetrisInput(e) {
            if(!currentPiece) return;
            if(e.key==='ArrowLeft' && !checkCollision(-1,0,currentPiece.matrix)) currentPiece.x--;
            if(e.key==='ArrowRight' && !checkCollision(1,0,currentPiece.matrix)) currentPiece.x++;
            if(e.key==='ArrowDown') moveDown();
            if(e.key==='ArrowUp') {
                let rotated = currentPiece.matrix[0].map((_, i) => currentPiece.matrix.map(row => row[i]).reverse());
                if(!checkCollision(0,0,rotated)) currentPiece.matrix = rotated;
            }
            drawTetris();
        }
        function checkCollision(x, y, matrix) {
            for(let r=0; r<matrix.length; r++){
                for(let c=0; c<matrix[r].length; c++){
                    if(matrix[r][c]){
                        let newX = currentPiece.x + c + x;
                        let newY = currentPiece.y + r + y;
                        if(newX < 0 || newX >= tetrisCols || newY >= tetrisRows) return true;
                        if(newY < 0) continue;
                        if(board[newY][newX]) return true;
                    }
                }
            }
            return false;
        }
        function lockPiece() {
            currentPiece.matrix.forEach((row, r) => {
                row.forEach((val, c) => {
                    if(val && currentPiece.y+r >= 0) board[currentPiece.y+r][currentPiece.x+c] = currentPiece.color;
                });
            });
            for(let r=0; r<tetrisRows; r++) {
                if(board[r].every(v => v !== null)) {
                    board.splice(r, 1);
                    board.unshift(Array(tetrisCols).fill(null));
                    score+=100; updateScore(score);
                }
            }
        }
        function drawTetris() {
            ctx.fillStyle = "#111"; ctx.fillRect(0,0,canvas.width,canvas.height);
            for(let r=0; r<tetrisRows; r++) for(let c=0; c<tetrisCols; c++) {
                drawSquare(c, r, board[r][c]);
            }
            if(currentPiece) currentPiece.matrix.forEach((row, r) => row.forEach((val, c) => {
                if(val) drawSquare(currentPiece.x+c, currentPiece.y+r, currentPiece.color);
            }));
        }
        function drawSquare(x, y, color) {
            if(!color) return;
            ctx.fillStyle = color; ctx.fillRect(x*tetrisSize, y*tetrisSize, tetrisSize, tetrisSize);
            ctx.strokeStyle = "#333"; ctx.strokeRect(x*tetrisSize, y*tetrisSize, tetrisSize, tetrisSize);
        }

        // ======================== PACMAN ========================
        const pacGrid = 20, pacCols = 19;
        const mapLayout = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,1,1,1,0,1,1,1,2,1,2,1,1,1,0,1,1,1,1],
            [2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2],
            [1,1,1,1,0,1,2,1,1,2,1,1,2,1,0,1,1,1,1],
            [1,0,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,0,0,1,0,0,0,0,0,3,0,0,0,0,0,1,0,0,1],
            [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        let pacman={}, ghosts=[], pacmanLives=3, pacMap=[];

        function initPacman() {
            canvas.width = pacCols * 30; canvas.height = mapLayout.length * 30;
            pacMap = JSON.parse(JSON.stringify(mapLayout));
            score=0; pacmanLives=3;
            resetPacPositions(); updateScore(0);
            gameInterval = setInterval(updatePacman, 150);
        }
        function resetPacPositions() {
            pacman = {x: 9, y: 12, dirX: 0, dirY: 0, nextDirX: 0, nextDirY: 0};
            ghosts = [{x:9, y:8, c:'red'}, {x:8, y:9, c:'pink'}, {x:10, y:9, c:'cyan'}];
        }
        function handlePacmanInput(e) {
            if(e.key==='ArrowUp') { pacman.nextDirX=0; pacman.nextDirY=-1; }
            if(e.key==='ArrowDown') { pacman.nextDirX=0; pacman.nextDirY=1; }
            if(e.key==='ArrowLeft') { pacman.nextDirX=-1; pacman.nextDirY=0; }
            if(e.key==='ArrowRight') { pacman.nextDirX=1; pacman.nextDirY=0; }
        }
        function updatePacman() {
            let nextX = pacman.x + pacman.nextDirX;
            let nextY = pacman.y + pacman.nextDirY;
            if (pacMap[nextY] && pacMap[nextY][nextX] !== 1) { pacman.dirX = pacman.nextDirX; pacman.dirY = pacman.nextDirY; }
            
            let moveX = pacman.x + pacman.dirX;
            let moveY = pacman.y + pacman.dirY;
            if (pacMap[moveY] && pacMap[moveY][moveX] !== 1) { pacman.x = moveX; pacman.y = moveY; }
            
            if(pacman.x < 0) pacman.x = pacCols - 1;
            if(pacman.x >= pacCols) pacman.x = 0;

            if (pacMap[pacman.y][pacman.x] === 0) { pacMap[pacman.y][pacman.x] = 2; score += 10; updateScore(score); }

            // Hayaletler
            ghosts.forEach(g => {
                let dirs = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}];
                let valid = dirs.filter(d => pacMap[g.y+d.y] && pacMap[g.y+d.y][g.x+d.x] !== 1);
                if(valid.length) { let m = valid[Math.floor(Math.random()*valid.length)]; g.x+=m.x; g.y+=m.y; }
                if(g.x===pacman.x && g.y===pacman.y) {
                    pacmanLives--; updateScore(score);
                    if(pacmanLives<=0) showGameOver(); else resetPacPositions();
                }
            });
            drawPacman();
        }
        function drawPacman() {
            let s = 30;
            ctx.fillStyle = "black"; ctx.fillRect(0, 0, canvas.width, canvas.height);
            for (let r=0; r<pacMap.length; r++) for (let c=0; c<pacMap[r].length; c++) {
                if(pacMap[r][c]===1) { ctx.strokeStyle="#1919A6"; ctx.lineWidth=2; ctx.strokeRect(c*s+5, r*s+5, s-10, s-10); }
                else if(pacMap[r][c]===0) { ctx.fillStyle="#ffb8ae"; ctx.fillRect(c*s+13, r*s+13, 4, 4); }
            }
            ctx.fillStyle = "yellow"; ctx.beginPath();
            ctx.arc(pacman.x*s+s/2, pacman.y*s+s/2, s/2-2, 0.2*Math.PI, 1.8*Math.PI); ctx.lineTo(pacman.x*s+s/2, pacman.y*s+s/2); ctx.fill();
            ghosts.forEach(g => { ctx.fillStyle=g.c; ctx.beginPath(); ctx.arc(g.x*s+s/2, g.y*s+s/2, s/2-4, 0, Math.PI*2); ctx.fill(); });
        }

    </script>
</body>
</html>
